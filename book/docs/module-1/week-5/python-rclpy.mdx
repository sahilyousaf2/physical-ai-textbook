---
sidebar_position: 3
---

# Python Integration with rclpy

This week, we'll explore the Python client library for ROS 2, called rclpy, which provides a Python API for ROS 2 concepts.

## Learning Objectives

After completing this week, you will be able to:

- Create ROS 2 nodes using Python and rclpy
- Implement publishers, subscribers, services, and clients in Python
- Work with parameters in Python nodes
- Use callbacks and timers effectively in Python

## Introduction to rclpy

rclpy is the Python client library for ROS 2. It provides a Python API that wraps the ROS 2 client library (rcl) and the ROS middleware (rmw).

### Basic Node Structure

```python
import rclpy
from rclpy.node import Node

class MyNode(Node):
    def __init__(self):
        super().__init__('my_node_name')
        # Node initialization code goes here

def main(args=None):
    rclpy.init(args=args)
    node = MyNode()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Working with Parameters

Parameters allow nodes to be configured at runtime:

```python
import rclpy
from rclpy.node import Node

class ParameterNode(Node):
    def __init__(self):
        super().__init__('parameter_node')

        # Declare parameters with default values
        self.declare_parameter('my_parameter', 'default_value')
        self.declare_parameter('number_parameter', 42)

        # Get parameter value
        param_value = self.get_parameter('my_parameter').value
        self.get_logger().info(f'Parameter value: {param_value}')

    def update_parameter_callback(self, parameter_list):
        for param in parameter_list:
            self.get_logger().info(f'Parameter {param.name} changed to {param.value}')
        return SetParametersResult(successful=True)

# Register callback for parameter changes
self.add_on_set_parameters_callback(self.update_parameter_callback)
```

## Creating Publishers and Subscribers in Python

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class TalkerListenerNode(Node):
    def __init__(self):
        super().__init__('talker_listener_node')

        # Create publisher
        self.publisher = self.create_publisher(String, 'topic', 10)

        # Create subscriber
        self.subscription = self.create_subscription(
            String,
            'topic',
            self.listener_callback,
            10)

        # Create timer for publishing
        self.timer = self.create_timer(0.5, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        msg = String()
        msg.data = f'Hello World: {self.i}'
        self.publisher.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"')
        self.i += 1

    def listener_callback(self, msg):
        self.get_logger().info(f'I heard: "{msg.data}"')
```

## Working with Services and Clients

### Service Server in Python

```python
from example_interfaces.srv import AddTwoInts
import rclpy
from rclpy.node import Node

class ServiceNode(Node):
    def __init__(self):
        super().__init__('service_node')
        self.srv = self.create_service(
            AddTwoInts,
            'add_two_ints',
            self.add_two_ints_callback)

    def add_two_ints_callback(self, request, response):
        response.sum = request.a + request.b
        self.get_logger().info(f'Request: {request.a} + {request.b}')
        return response
```

### Service Client in Python

```python
from example_interfaces.srv import AddTwoInts
import rclpy
from rclpy.node import Node

class ClientNode(Node):
    def __init__(self):
        super().__init__('client_node')
        self.client = self.create_client(AddTwoInts, 'add_two_ints')

        while not self.client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Service not available, waiting...')

        self.request = AddTwoInts.Request()

    def send_request(self, a, b):
        self.request.a = a
        self.request.b = b
        future = self.client.call_async(self.request)
        return future
```

## Working with Actions

Actions provide goal-oriented communication with feedback:

```python
from example_interfaces.action import Fibonacci
import rclpy
from rclpy.action import ActionServer, GoalResponse, CancelResponse
from rclpy.node import Node

class FibonacciActionServer(Node):
    def __init__(self):
        super().__init__('fibonacci_action_server')
        self._action_server = ActionServer(
            self,
            Fibonacci,
            'fibonacci',
            execute_callback=self.execute_callback,
            goal_callback=self.goal_callback,
            cancel_callback=self.cancel_callback)

    def goal_callback(self, goal_request):
        self.get_logger().info('Received goal request')
        return GoalResponse.ACCEPT

    def cancel_callback(self, goal_handle):
        self.get_logger().info('Received cancel request')
        return CancelResponse.ACCEPT

    def execute_callback(self, goal_handle):
        self.get_logger().info('Executing goal...')

        feedback_msg = Fibonacci.Feedback()
        feedback_msg.sequence = [0, 1]

        for i in range(1, goal_handle.request.order):
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                self.get_logger().info('Goal canceled')
                return Fibonacci.Result()

            feedback_msg.sequence.append(
                feedback_msg.sequence[i] + feedback_msg.sequence[i-1])
            goal_handle.publish_feedback(feedback_msg)

        goal_handle.succeed()
        result = Fibonacci.Result()
        result.sequence = feedback_msg.sequence
        return result
```

import Exercise from '@site/src/components/Exercise';

<Exercise
  title="Create a Parameterized Publisher"
  difficulty="intermediate"
  estimatedTime={60}
  type="coding"
>

Create a Python node that:

1. Declares a parameter for the message content
2. Uses a timer to publish the parameterized message
3. Updates the message when the parameter changes

```bash
# To change the parameter while the node is running:
ros2 param set /your_node_name your_param_name "new value"
```

</Exercise>

## Summary

rclpy provides a comprehensive Python API for all ROS 2 concepts. Understanding how to work with nodes, parameters, publishers, subscribers, services, and actions in Python is essential for ROS 2 development.

## Next Steps

[Previous: Week 4 - ROS 2 Nodes, Topics, and Services](../week-4/nodes-topics-services)